# Hirschberg-Sinclair-algorithm-for-leader-election-using-Java-RMI
# In order to execute this program, first install the RMI plugin for Eclipse or it can be done without installing that but that would require one to gothrough a number of complex steps which are taken cared off by this plugin. The plugin is available at http://www.genady.net/rmi/v20/.
# To implement the algorithm Java RMI was used and to do so a RMI plug-in for eclipse was downloaded which automates the process of configuring the environment and the compiler for RMI and generates the RMI registry on the click of a button. A new java project was created with two independent packages, client and server, and the files of these two packages interact with each other using RMI. 
# To implement the algorithm, each node in the ring structure is given a unique NID which is assigned using the Math.random() function. Each node is represented as a different thread/process is ThreadInitiator.java and a separate JVM is maintained for each node. Owing to each node being a different process, all interactions are made using message passing through the RMI API. The main in HSLeaderElection.java is used to generate the number of nodes as per the given argument and assigns the NID. It also gives the ring structure. All the nodes are registered into the rmiregistry and each node waits until all its neighbors are registered into the registry. The node with the highest NID is the leader of the ring. Each node then passes its value to the nearest neighbor in phase 1 and if it gets the same number of messages as it had sent only then it sends its NID to the processes in phase 2 else that node opts out of the election process and does not proceed to phase 2. 
# The server interface HSLeaderElectionIntf.java basically inherits or extends the Remote class which allows it to create remote objects which are accessible via other JVM. Implementing this interface on server side, all the server objects that are create are remote objects. As per the requirement of the assignment, the number of messages and the process of leader election is maintained in StatusManager.java. Elector.java passes a message to the client about starting the election process and which initiates the leader election process. In Leader.java the NID of different nodes are compared in phases and nodes are dropped out from the election process until we have one victorious leader. On the client side, once the leader is found in leader.java, the program sends a notification to all other nodes that the leader has been found using the notifyall() function.
